//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES			
#include <SI_EFM8BB1_Register_Enums.h>

//-----------------------------------------------------------------------------
// Pin Definitions
//-----------------------------------------------------------------------------
SI_SBIT(BTN0, SFR_P0, 2);
#define BTN0_PRESSED (0)

//-----------------------------------------------------------------------------
// Global CONSTANTS
//-----------------------------------------------------------------------------
#define TIMER0_NUM_STEPS 8

// TIMER0 reload values for various pulse frequencies
// values were calculated with Hardware Configurator
const uint8_t code TIMER0_RELOAD_VALUES[TIMER0_NUM_STEPS] = {
    0xA0, // 0.5 Hz pulse
    0xC0, // 0.75 Hz pulse
    0xD0, // 1 Hz pulse
    0xE0, // 1.5 Hz pulse
    0xE8, // 2 Hz pulse
    0xF0, // 3 Hz pulse
    0xF4, // 4 Hz pulse
    0xF8};// 6 Hz pulse

//-----------------------------------------------------------------------------
// PMATCH_ISR
//-----------------------------------------------------------------------------
//
// PMATCH ISR Content goes here. Remember to clear flag bits:
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(PMATCH_ISR, PMATCH_IRQn)
{
  static uint8_t reloadIndex = 1;

  // Update pulse frequency
  TH0 = TIMER0_RELOAD_VALUES[reloadIndex];
  TL0 = TIMER0_RELOAD_VALUES[reloadIndex];

  // Reset to lowest frequency if we've reached the last value in the array
  reloadIndex += 1;
  if (reloadIndex == TIMER0_NUM_STEPS) {
    reloadIndex = 0;
  }

  // Disable PMATCH interrupt until BTN0 is released.
  EIE1 &= ~EIE1_EMAT__BMASK;
}

//-----------------------------------------------------------------------------
// PCA0_ISR
//-----------------------------------------------------------------------------
//
// PCA0 ISR Content goes here. Remember to clear flag bits:
// PCA0CN0::CCF0 (PCA Module 0 Capture/Compare Flag)
// PCA0CN0::CCF1 (PCA Module 1 Capture/Compare Flag)
// PCA0CN0::CCF2 (PCA Module 2 Capture/Compare Flag)
// PCA0CN0::CF (PCA Counter/Timer Overflow Flag)
// PCA0PWM::COVF (Cycle Overflow Flag)
//
// Duty cycle percentage is PCA0CPL0 / 256
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(PCA0_ISR, PCA0_IRQn)
{
  static int8_t direction = 1;
  static uint8_t duty = 0x80;

  // Clear overflow flag
  PCA0PWM &= ~PCA0PWM_COVF__BMASK;

  // Increase (or decrease, depending on up/down) duty
  duty += direction;

  // Once duty reaches the top or bottom value, reverse direction
  if (duty == 0xFF || duty == 0) {
    direction *= -1;
  }

  // Load the duty value into the PCA
  // PCA0CPH0 is loaded into PCA0CPL0 on the next cycle overflow
  PCA0CPH0 = duty;
}

