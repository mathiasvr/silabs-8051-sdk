//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES			
#include <SI_EFM8BB1_Register_Enums.h>
#include "EFM8BB1_SMBus_Multimaster.h"

//-----------------------------------------------------------------------------
// Pin Definitions
//-----------------------------------------------------------------------------

SI_SBIT(LED1, SFR_P1, 4);// Green LED

//-----------------------------------------------------------------------------
// TIMER0_ISR
//-----------------------------------------------------------------------------
//
// TIMER0 ISR Content goes here. Remember to clear flag bits:
// TCON::TF0 (Timer 0 Overflow Flag)
//
// Timer0 blinks the LED when instructed by the other multimaster.
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(TIMER0_ISR, TIMER0_IRQn)
{
	static uint8_t count = 0;                // Count up to 256 Timer 0 interrupts
										// before toggling Green LED.
										// Otherwise, it won't be visible to
										// the eye.
	TCON_TF0 = 0;
	if(count == 255)
	{
		LED1 = !LED1;                    // Turn the LED on and off

		count = 0;
	}
	else
	{
		count++;
	}
}

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN::SI (SMBus Interrupt Flag)
//
// SMBus ISR state machine
// - Master only implementation - no slave or arbitration states defined
// - Incoming master data is written to global variable <SMB_DATA_IN_MASTER>
// - Incoming slave data is written to global variable <SMB_DATA_IN_SLAVE>
// - Outgoing master data is read from global variable <SMB_DATA_OUT_MASTER>
// - Outgoing slave data is read from global variable <SMB_DATA_OUT_SLAVE>
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
{
	bool M_FAIL = 0;                     // Used by the master states to flag a
										// bus error condition
										// transfers

	static bool ADDR_SEND = 0;// Used by the ISR to flag byte
							 // transmissions as slave addresses

	static bool arbitration_lost = 0;// Used by the ISR to flag whether
									// arbitration was lost and the transfer
									// should be rescheduled

									// Normal operation
	switch (SMB0CN0 & 0xF0)			// Status vector
	{
		// SMB0CN_MASTER ---------------------------------------------------------------

		// Master Transmitter/Receiver: START condition transmitted.
		case SMB_MTSTA:
		SMB0DAT = TARGET;// Load address of the target slave
		SMB0DAT &= 0xFE; // Clear the LSB of the address for the
						 // R/W bit
		SMB0DAT |= SMB_RW;// Load R/W bit
		SMB0CN0_STA = 0; // Manually clear START bit
		ADDR_SEND = 1;

		break;

						 // Master Transmitter: Data byte transmitted
		case SMB_MTDB:

		if(SMB0CN0_ARBLOST == 0)// Check for a bus error
		{
			if(SMB0CN0_ACK)                    // Slave SMB0CN_ACK?
			{
				if(ADDR_SEND)           // If the previous byte was a slave
				{                       // address,
					ADDR_SEND = 0;// Next byte is not a slave address
					if (SMB_RW == WRITE)// If this transfer is a WRITE,
					{
						// Send data byte
						SMB0DAT = SMB_DATA_OUT_MASTER;
					}
					else {}              // If this transfer is a READ,
										 // proceed with transfer without
										 // writing to SMB0DAT (switch
										 // to receive mode)
				}
				else                    // If previous byte was not a slave
				{                       // address,
					SMB0CN0_STO = 1;// Set SMB0CN_STO to terminate transfer
					SMB_BUSY = 0;// And free SMBus interface
				}
			}
			else                       // If slave NACK,
			{
				SMB0CN0_STO = 1;                // Send STOP condition, followed
				SMB0CN0_STA = 1;// By a START
				NUM_ERRORS++;// Indicate error
			}
		}
		else
		{
			M_FAIL = 1;                // If a bus error occurs, reset
		}

		break;

		// Master Receiver: byte received
		case SMB_MRDB:

		if(SMB0CN0_ARBLOST == 0)// Check for a bus error
		{
			// Store received byte
			SMB_DATA_IN_MASTER = SMB0DAT;
			SMB_BUSY = 0;// Free SMBus interface
			SMB0CN0_ACK = 0;// Send NACK to indicate last byte
			// of this transfer

			SMB0CN0_STO = 1;// Send STOP to terminate transfer
		}
		else
		{
			M_FAIL = 1;                // If a bus error occurs, reset
		}

		break;

		// ----------------------------------------------------------------------

		// SLAVE ----------------------------------------------------------------

		// Slave Receiver: Start+Address received
		case SMB_SRADD:

		if (SMB0CN0_ARBLOST == 1)
		{
			arbitration_lost = 1;      // Indicate lost arbitration
		}

		SMB0CN0_STA = 0;                      // Clear SMB0CN_STA bit
		if((SMB0DAT&0xFE) == (MY_ADDR&0xFE))// Decode address
		{                             // If the received address matches,
			SMB0CN0_ACK = 1;// SMB0CN_ACK the received slave address
			if((SMB0DAT&0x01) == READ)// If the transfer is a master READ
			{
				// Prepare outgoing byte
				SMB0DAT = SMB_DATA_OUT_SLAVE;
			}
		}
		else                          // If received slave address does not
		{                             // match,
			SMB0CN0_ACK = 0;// NACK received address
		}

		break;

		// Slave Receiver: Data received
		case SMB_SRDB:

		if(SMB0CN0_ARBLOST == 0)// No bus error
		{

			// Store incoming data
			SMB_DATA_IN_SLAVE = SMB0DAT;

			DATA_READY = 1;// Indicate new data received
			SMB0CN0_ACK = 1;// SMB0CN_ACK received data
		}
		else                          // Bus error detected
		{
			SMB0CN0_STA = 0;
			SMB0CN0_STO = 0;
			SMB0CN0_ACK = 0;
		}

		break;

		// Slave Receiver: Stop received while either a Slave Receiver or Slave
		// Transmitter
		case SMB_SRSTO:

		if(arbitration_lost == 1)
		{
			SMB0CN0_STA = 1;      // The SMB0CN_ARBLOST bit indicated the master
			// lost arbitration
			// reschedule the transfer

			arbitration_lost = 0;
		}

		SMB0CN0_STO = 0;          // SMB0CN_STO must be cleared by software when
		// a STOP is detected as a slave
		break;

		// Slave Transmitter: Data byte transmitted
		case SMB_STDB:
		// No action required;
		// one-byte transfers
		// only for this example
		break;

		// Slave Transmitter: Arbitration lost, Stop detected
		//
		// This state will only be entered on a bus error condition.
		// In normal operation, the slave is no longer sending data or has
		// data pending when a STOP is received from the master, so the SMB0CN_TXMODE
		// bit is cleared and the slave goes to the SRSTO state.
		case SMB_STSTO:

		SMB0CN0_STO = 0;// SMB0CN_STO must be cleared by software when
		// a STOP is detected as a slave
		break;

		// Default: all other cases undefined

		// ----------------------------------------------------------------------

		default:
		M_FAIL = 1;// Indicate failed transfer
				   // and handle at end of ISR
		break;

	} // end switch

	if(M_FAIL)// If the transfer failed,
	{
		SMB0CF &= ~0x80;                 // Reset communication
		SMB0CF |= 0x80;
		SMB0CN0_STA = 0;
		SMB0CN0_STO = 0;
		SMB0CN0_ACK = 0;

		SMB_BUSY = 0;// Free SMBus

		M_FAIL = 0;
		LED1 = LED_OFF;

		NUM_ERRORS++;// Indicate an error occurred
	}

	SMB0CN0_SI = 0;                             // Clear interrupt flag
}

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
//
// A Timer3 interrupt indicates an SMBus SCL low timeout.
// The SMBus is disabled and re-enabled here
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
{
	SMB0CF &= ~0x80;                    // Disable SMBus
	SMB0CF |= 0x80;// Re-enable SMBus
	TMR3CN0 &= ~0x80;// Clear Timer3 interrupt-pending flag
	SMB0CN0_STA = 0;
	SMB_BUSY = 0;// Free SMBus
}

