//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// -----------------------------------------------------------------------------
// Includes

#include <SI_EFM8UB2_Register_Enums.h>
#include "bsp.h"
#include "descriptor.h"
#include "joystick.h"

// -----------------------------------------------------------------------------
// Constants

// -------------------------------
// ADC Sampling Constants

#define SYSCLK                    48000000
#define ADC0_SAMPLING_FREQUENCY   4    // Frequency to sample ADC
#define T0_CLOCKS 120                  // Use 120 clocks per T0 Overflow

// SYSCLK cycles per interrupt
#define PCA_TIMEOUT ((SYSCLK/T0_CLOCKS)/ADC0_SAMPLING_FREQUENCY/4)

// -------------------------------
// Temperature Sensor Coefficients

#define SCALE       1000L   // Scale for temp calculations
#define SLOPE       3294    // Slope of the temp transfer function
#define OFFSET      266202L // Offset for the temp transfer function
#define OVER_ROUND  10      // Number of shifts (>>N) to reach the
                            // correct number of bits of precision

// -----------------------------------------------------------------------------
// Variables

uint16_t writeLen;
volatile uint8_t joystickDirection;

// -----------------------------------------------------------------------------
// Extern Variables

extern volatile uint8_t joystickValue;
extern volatile uint8_t temperature;
extern bool pb0State;
extern bool pb1State;
extern SI_SEGMENT_VARIABLE(inPacket[USB_PACKET_SIZE], uint8_t, SI_SEG_XDATA);

// -----------------------------------------------------------------------------
// Function Prototypes

static uint8_t remap_joystick(uint8_t joystickValue);

// -----------------------------------------------------------------------------
// Functions

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(ADC0EOC_ISR, ADC0EOC_IRQn)
{
  // correct number of bits of precision
  uint16_t sample;
  int32_t temp_scaled;
  int16_t temp_frac;
  uint32_t mv;

  // Temperature Sensor reading
  if (AMX0P == AMX0P_AMX0P__TEMP)
  {
    temp_scaled = ADC0;
    temp_scaled *= SLOPE;

    // With a left-justified ADC, we have to shift the decimal place
    // of temp_scaled to the right so we can match the format of
    // OFFSET. Once the formats are matched, we can subtract OFFSET.
    temp_scaled = temp_scaled >> OVER_ROUND;
    temp_scaled -= OFFSET;

    // Calculate the temp's whole number portion by unscaling
    temperature = temp_scaled / SCALE;

    // Get the fractional part and round temperature as needed
    temp_frac = (int16_t)((temp_scaled - temperature * SCALE) / (SCALE / 10));

    if (temp_frac > 5)
    {
      temperature++;
    }
    else if (temp_frac < -5)
    {
      temperature--;
    }

    // Switch ADC0 setting for joystick
    AMX0P = AMX0P_AMX0P__ADC0P4;
    ADC0CF &= ~ADC0CF_ADLJST__LEFT_JUSTIFIED;
  }
  // Joystick reading
  else
  {
    sample = ADC0;
    mv = ((uint32_t)sample) * 3300 / 1024;

    joystickDirection = JOYSTICK_convert_mv_to_direction(mv);
    joystickValue = remap_joystick(joystickDirection);

    // Switch ADC0 setting for temperature sensor
    AMX0P = AMX0P_AMX0P__TEMP;
    ADC0CF |= ADC0CF_ADLJST__LEFT_JUSTIFIED;
  }

  ADC0CN0_ADINT = 0;

  USBX_blockWrite(inPacket, USB_PACKET_SIZE, &writeLen);
}

//-----------------------------------------------------------------------------
// INT0_ISR
//-----------------------------------------------------------------------------
//
// INT0 ISR Content goes here. Remember to clear flag bits:
// TCON::IE0 (External Interrupt 0)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(INT0_ISR, INT0_IRQn)
{
  // PB0 is now low
  if ((IT01CF & IT01CF_IN0PL__BMASK) == IT01CF_IN0PL__ACTIVE_LOW)
  {
    IT01CF |= IT01CF_IN0PL__ACTIVE_HIGH;
  }
  // PB0 is now high
  else
  {
    // At this point, PB0 has been pressed and released.
    // Toggle pb0State
    pb0State = ~pb0State;
    IT01CF &= ~IT01CF_IN0PL__ACTIVE_HIGH;
  }
}

//-----------------------------------------------------------------------------
// INT1_ISR
//-----------------------------------------------------------------------------
//
// INT1 ISR Content goes here. Remember to clear flag bits:
// TCON::IE1 (External Interrupt 1)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(INT1_ISR, INT1_IRQn)
{
  // PB1 is now low
  if ((IT01CF & IT01CF_IN1PL__BMASK) == IT01CF_IN1PL__ACTIVE_LOW)
  {
    IT01CF |= IT01CF_IN1PL__ACTIVE_HIGH;
  }
  // PB1 is now high
  else
  {
    // At this point, PB1 has been pressed and released.
    // Toggle pb1State
    pb1State = ~pb1State;
    IT01CF &= ~IT01CF_IN1PL__ACTIVE_HIGH;
  }
}
//-----------------------------------------------------------------------------
// PCA0_ISR
//-----------------------------------------------------------------------------
//
// PCA0 ISR Content goes here. Remember to clear flag bits:
// PCA0CN0::CCF0 (PCA Module 0 Capture/Compare Flag)
// PCA0CN0::CCF1 (PCA Module 1 Capture/Compare Flag)
// PCA0CN0::CCF2 (PCA Module 2 Capture/Compare Flag)
// PCA0CN0::CCF3 (PCA Module 3 Capture/Compare Flag)
// PCA0CN0::CCF4 (PCA Module 4 Capture/Compare Flag)
// PCA0CN0::CF (PCA Counter/Timer Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(PCA0_ISR, PCA0_IRQn)
{
  static uint16_t NEXT_COMPARE_VALUE;

  if (PCA0CN0_CCF0)                           // If Module 0 caused the interrupt
  {
     PCA0CN0_CCF0 = 0;                        // Clear module 0 interrupt flag.

     PCA0CPL0 = (NEXT_COMPARE_VALUE & 0x00FF);
     PCA0CPH0 = (NEXT_COMPARE_VALUE & 0xFF00)>>8;

     // Set up the variable for the following edge
     NEXT_COMPARE_VALUE = PCA0CP0 + PCA_TIMEOUT;

     // Trigger the next ADC measurement
     ADC0CN0_ADBUSY = 1;
  }
  else                                // Interrupt was caused by other bits.
  {
     PCA0CN0 &= ~0x86;                 // Clear other interrupt flags for PCA
  }
}

/**************************************************************************//**
 * @brief
 *   Converts internal joystick direction value to a value between 0 and 255
 *   for display by the TestPanel application.
 *
 * @param   joystickValue:
 *   Direction of joystick as returned by the BSP function
 *   JOYSTICK_convert_mv_to_direction().
 * @return
 *   This function scales the value so that it will display nicely in
 *   the TestPanel application.
 *
 *****************************************************************************/
static uint8_t remap_joystick(uint8_t joystickValue)
{
  uint8_t retval = 0;

  // Treat the joystick as if it is an analog clock.
  switch (joystickValue)
  {
    case JOYSTICK_NONE:
      retval = 0;
      break;
    case JOYSTICK_C:
      retval = 128;
      break;
    case JOYSTICK_N:
      retval = 255;
      break;
    case JOYSTICK_E:
      retval = 64;
      break;
    case JOYSTICK_S:
      retval = 128;
      break;
    case JOYSTICK_W:
      retval = 192;
      break;
    case JOYSTICK_NE:
      retval = 32;
      break;
    case JOYSTICK_NW:
      retval = 224;
      break;
    case JOYSTICK_SE:
      retval = 96;
      break;
    case JOYSTICK_SW:
      retval = 160;
      break;
  }

  return retval;
}
