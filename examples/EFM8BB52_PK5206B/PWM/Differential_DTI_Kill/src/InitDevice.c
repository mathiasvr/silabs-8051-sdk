//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8BB52_Register_Enums.h>
#include "InitDevice.h"

// USER PROTOTYPES
// USER FUNCTIONS

// $[Library Includes]
// [Library Includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
  // $[Config Calls]
  // Save the SFRPAGE
  uint8_t SFRPAGE_save = SFRPAGE;
  WDT_0_enter_DefaultMode_from_RESET();
  PORTS_0_enter_DefaultMode_from_RESET();
  PORTS_1_enter_DefaultMode_from_RESET();
  PBCFG_0_enter_DefaultMode_from_RESET();
  CLU_3_enter_DefaultMode_from_RESET();
  CL_0_enter_DefaultMode_from_RESET();
  AMUXCP_0_enterDefaultMode_from_RESET();
  CMP_1_enter_CompareMode_from_RESET();
  TIMER16_2_enter_DefaultMode_from_RESET();
  INTERRUPT_0_enter_DefaultMode_from_RESET();
  // Restore the SFRPAGE
  SFRPAGE = SFRPAGE_save;
  // [Config Calls]$
}

//================================================================================
// WDT_0_enter_DefaultMode_from_RESET
//================================================================================
extern void WDT_0_enter_DefaultMode_from_RESET(void) {
  // $[Watchdog Timer Init Variable Declarations]
  // [Watchdog Timer Init Variable Declarations]$
  
  // $[WDTCN - Watchdog Timer Control]
  SFRPAGE = 0x00;
  //Disable Watchdog with key sequence
  WDTCN = 0xDE; //First key
  WDTCN = 0xAD; //Second key
  // [WDTCN - Watchdog Timer Control]$
}

//================================================================================
// PORTS_0_enter_DefaultMode_from_RESET
//================================================================================
extern void
PORTS_0_enter_DefaultMode_from_RESET (void)
{
  // $[P0 - Port 0 Pin Latch]
  // [P0 - Port 0 Pin Latch]$

  // $[P0MDOUT - Port 0 Output Mode]
  // [P0MDOUT - Port 0 Output Mode]$

  // $[P0MDIN - Port 0 Input Mode]
  /***********************************************************************
   - P0.0 pin is configured for analog mode
   - P0.1 pin is configured for analog mode
   - P0.2 pin is configured for digital mode
   - P0.3 pin is configured for digital mode
   - P0.4 pin is configured for analog mode
   - P0.5 pin is configured for analog mode
   - P0.6 pin is configured for analog mode
   - P0.7 pin is configured for analog mode
   ***********************************************************************/
  P0MDIN = P0MDIN_B0__ANALOG | P0MDIN_B1__ANALOG | P0MDIN_B2__DIGITAL
      | P0MDIN_B3__DIGITAL | P0MDIN_B4__DIGITAL | P0MDIN_B5__ANALOG
      | P0MDIN_B6__ANALOG | P0MDIN_B7__ANALOG;
  // [P0MDIN - Port 0 Input Mode]$

  // $[P0SKIP - Port 0 Skip]
  /***********************************************************************
   - P0.0 pin is skipped by the crossbar
   - P0.1 pin is skipped by the crossbar
   - P0.2 pin is skipped by the crossbar
   - P0.3 pin is skipped by the crossbar
   - P0.4 pin is skipped by the crossbar
   - P0.5 pin is skipped by the crossbar
   - P0.6 pin is skipped by the crossbar
   - P0.7 pin is skipped by the crossbar
   ***********************************************************************/
  P0SKIP = P0SKIP_B0__SKIPPED | P0SKIP_B1__SKIPPED | P0SKIP_B2__SKIPPED
      | P0SKIP_B3__SKIPPED | P0SKIP_B4__SKIPPED | P0SKIP_B5__SKIPPED
      | P0SKIP_B6__SKIPPED | P0SKIP_B7__SKIPPED;
  // [P0SKIP - Port 0 Skip]$

  // $[P0MASK - Port 0 Mask]
  // [P0MASK - Port 0 Mask]$

  // $[P0MAT - Port 0 Match]
  // [P0MAT - Port 0 Match]$

}

//================================================================================
// PORTS_1_enter_DefaultMode_from_RESET
//================================================================================
extern void
PORTS_1_enter_DefaultMode_from_RESET (void)
{
  // $[P1 - Port 1 Pin Latch]
  // [P1 - Port 1 Pin Latch]$

  // $[P1MDOUT - Port 1 Output Mode]
  /***********************************************************************
   - P1.0 output is open-drain
   - P1.1 output is open-drain
   - P1.2 output is open-drain
   - P1.3 output is open-drain
   - P1.4 output is push-pull
   - P1.5 output is push-pull
   - P1.6 output is push-pull
   - P1.7 output is open-drain
   ***********************************************************************/
  P1MDOUT = P1MDOUT_B0__OPEN_DRAIN | P1MDOUT_B1__OPEN_DRAIN
      | P1MDOUT_B2__OPEN_DRAIN | P1MDOUT_B3__OPEN_DRAIN | P1MDOUT_B4__PUSH_PULL
      | P1MDOUT_B5__PUSH_PULL | P1MDOUT_B6__PUSH_PULL | P1MDOUT_B7__OPEN_DRAIN;
  // [P1MDOUT - Port 1 Output Mode]$

  // $[P1MDIN - Port 1 Input Mode]
  /***********************************************************************
   - P1.0 pin is configured for analog mode
   - P1.1 pin is configured for analog mode
   - P1.2 pin is configured for analog mode
   - P1.3 pin is configured for analog mode
   - P1.4 pin is configured for digital mode
   - P1.5 pin is configured for digital mode
   - P1.6 pin is configured for digital mode
   - P1.7 pin is configured for analog mode
   ***********************************************************************/
  P1MDIN = P1MDIN_B0__ANALOG | P1MDIN_B1__ANALOG | P1MDIN_B2__ANALOG
      | P1MDIN_B3__ANALOG | P1MDIN_B4__DIGITAL | P1MDIN_B5__DIGITAL
      | P1MDIN_B6__DIGITAL | P1MDIN_B7__ANALOG;
  // [P1MDIN - Port 1 Input Mode]$

  // $[P1SKIP - Port 1 Skip]
  /***********************************************************************
   - P1.0 pin is skipped by the crossbar
   - P1.1 pin is skipped by the crossbar
   - P1.2 pin is skipped by the crossbar
   - P1.3 pin is skipped by the crossbar
   - P1.4 pin is not skipped by the crossbar
   - P1.5 pin is not skipped by the crossbar
   - P1.6 pin is not skipped by the crossbar
   - P1.7 pin is not skipped by the crossbar
   ***********************************************************************/
  P1SKIP = P1SKIP_B0__SKIPPED | P1SKIP_B1__SKIPPED | P1SKIP_B2__SKIPPED
      | P1SKIP_B3__SKIPPED | P1SKIP_B4__NOT_SKIPPED | P1SKIP_B5__NOT_SKIPPED
      | P1SKIP_B6__NOT_SKIPPED | P1SKIP_B7__NOT_SKIPPED;
  // [P1SKIP - Port 1 Skip]$

  // $[P1MASK - Port 1 Mask]
  // [P1MASK - Port 1 Mask]$

  // $[P1MAT - Port 1 Match]
  // [P1MAT - Port 1 Match]$

}

//================================================================================
// PBCFG_0_enter_DefaultMode_from_RESET
//================================================================================
extern void
PBCFG_0_enter_DefaultMode_from_RESET (void)
{
  // $[XBR2 - Port I/O Crossbar 2]
  /***********************************************************************
   - Weak Pullups enabled
   - Crossbar enabled
   - Two outputs per enabled PWM channel.
   - PWM0 Ch0 routed to Port pin.
   - UART1 I/O unavailable at Port pin
   - UART1 RTS1 unavailable at Port pin
   - UART1 CTS1 unavailable at Port pin
   ***********************************************************************/
  XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED | XBR2_XBARE__ENABLED
      | XBR2_PWMDE__DIFF | XBR2_PWME__PWM0CH0 | XBR2_URT1E__DISABLED
      | XBR2_URT1RTSE__DISABLED | XBR2_URT1CTSE__DISABLED;
  // [XBR2 - Port I/O Crossbar 2]$

  // $[PRTDRV - Port Drive Strength]
  // [PRTDRV - Port Drive Strength]$

  // $[XBR0 - Port I/O Crossbar 0]
  // [XBR0 - Port I/O Crossbar 0]$

  // $[XBR1 - Port I/O Crossbar 1]
  // [XBR1 - Port I/O Crossbar 1]$

}

//================================================================================
// AMUXCP_0_enter_DefaultMode_from_RESET
//================================================================================
extern void AMUXCP_0_enterDefaultMode_from_RESET(void){
    uint8_t i;

    // $[CLKGRP0 - Clock Group 0]
    /***********************************************************************
     - Enable AMUXCP clock derived from the Internal High Frequency Oscillator 0
     ***********************************************************************/
    SFRPAGE = 0x30;
    CLKGRP0 |= CLKGRP0_EN_CPCLK__ENABLE;
    // [CLKGRP0 - Clock Group 0]$

    // $[CP0CN - AMUXCP Control 0]
    CP0CN |= CP0CN_EN_CPLDO__ENABLED;
    for (i = 0; i < 200; i++);
    CP0CN |= CP0CN_EN_CP__ENABLED;
    while ((CP0CN & CP0CN_CP_STARTUP_DONE__BMASK) == CP0CN_CP_STARTUP_DONE__ONGOING);
    // [CP0CN - AMUXCP Control 0]$
}

//================================================================================
// CLU_3_enter_DefaultMode_from_RESET
//================================================================================
extern void CLU_3_enter_DefaultMode_from_RESET(void) {
  // $[CLU3FN - Configurable Logic Unit 3 Function Select]
  /*
   // FNSEL (CLU Look-Up-Table function select) = 0xF0
   */
  SFRPAGE = 0x20;
  CLU3FN = (0x0F << CLU3FN_FNSEL__SHIFT);
  // [CLU3FN - Configurable Logic Unit 3 Function Select]$

  // $[CLU3MX - Configurable Logic Unit 3 Multiplexer]
  /*
   // MXA (CLU3 A Input Multiplexer Selection) = CLU3A9 (Select CLU3A.9)
   // MXB (CLU3 B Input Multiplexer Selection) = CLU3B9 (Select CLU3B.9)
   */
  CLU3MX = CLU3MX_MXA__CLU3A8 | CLU3MX_MXB__CLU3B10;
  // [CLU3MX - Configurable Logic Unit 3 Multiplexer]$

  // $[CLU3CF - Configurable Logic Unit 3 Configuration]
  /*
   // OUTSEL (CLU Output Select) = LUT (Select LUT output.)
   */
  CLU3CF |= CLU3CF_OUTSEL__LUT;
  // [CLU3CF - Configurable Logic Unit 3 Configuration]$

}

//================================================================================
// CL_0_enter_DefaultMode_from_RESET
//================================================================================
extern void CL_0_enter_DefaultMode_from_RESET(void) {
  // $[CLEN0 - Configurable Logic Enable 0]
  /*
   // C0EN (CLU3 Enable) = DISABLE (CLU0 is disabled. The output of the
   //     block will be logic low.)
   // C1EN (CLU1 Enable) = DISABLE (CLU1 is disabled. The output of the
   //     block will be logic low.)
   // C2EN (CLU2 Enable) = DISABLE (CLU2 is disabled. The output of the
   //     block will be logic low.)
   // C3EN (CLU3 Enable) = ENABLE (CLU3 is enabled.)
   */
  CLEN0 = CLEN0_C0EN__DISABLE | CLEN0_C1EN__DISABLE | CLEN0_C2EN__DISABLE
      | CLEN0_C3EN__ENABLE;
  // [CLEN0 - Configurable Logic Enable 0]$

  // $[CLIE0 - Configurable Logic Interrupt Enable 0]
  // [CLIE0 - Configurable Logic Interrupt Enable 0]$

}

//================================================================================
// INTERRUPT_0_enter_DefaultMode_from_RESET
//================================================================================
extern void
INTERRUPT_0_enter_DefaultMode_from_RESET (void)
{
  // $[EIE1 - Extended Interrupt Enable 1]
  // [EIE1 - Extended Interrupt Enable 1]$

  // $[EIE2 - Extended Interrupt Enable 2]
  // [EIE2 - Extended Interrupt Enable 2]$

  // $[EIP1H - Extended Interrupt Priority 1 High]
  // [EIP1H - Extended Interrupt Priority 1 High]$

  // $[EIP1 - Extended Interrupt Priority 1 Low]
  // [EIP1 - Extended Interrupt Priority 1 Low]$

  // $[EIP2 - Extended Interrupt Priority 2]
  // [EIP2 - Extended Interrupt Priority 2]$

  // $[EIP2H - Extended Interrupt Priority 2 High]
  // [EIP2H - Extended Interrupt Priority 2 High]$

  // $[IE - Interrupt Enable]
  /***********************************************************************
   - Enable each interrupt according to its individual mask setting
   - Disable external interrupt 0
   - Disable external interrupt 1
   - Disable all SPI0 interrupts
   - Disable all Timer 0 interrupt
   - Disable all Timer 1 interrupt
   - Enable interrupt requests generated by the TF2L or TF2H flags
   - Disable UART0 interrupt
   ***********************************************************************/
  IE = IE_EA__ENABLED | IE_EX0__DISABLED | IE_EX1__DISABLED | IE_ESPI0__DISABLED
      | IE_ET0__DISABLED | IE_ET1__DISABLED | IE_ET2__ENABLED
      | IE_ES0__DISABLED;
  // [IE - Interrupt Enable]$

  // $[IP - Interrupt Priority]
  // [IP - Interrupt Priority]$

  // $[IPH - Interrupt Priority High]
  // [IPH - Interrupt Priority High]$

}

//================================================================================
// CMP_1_enter_CompareMode_from_RESET
//================================================================================
extern void CMP_1_enter_CompareMode_from_RESET(void) {
  // $[CMP1MX - Comparator 1 Multiplexer Selection]
  /*
   // CMXP (Comparator Positive Input MUX Selection) = CMP1P0 (External pin
   //     CMP1P0)
   // CMXN (Comparator Negative Input MUX Selection) = CMP1N11 (Internal DAC)
   */
  CMP1MX = CMP1MX_CMXP__CMP1P0 | CMP1MX_CMXN__CMP1N11;
  // [CMP1MX - Comparator 1 Multiplexer Selection]$

  // $[CMP1CN1 - Comparator 1 Control 1]
  /*
   * DACLVL (Internal Comparator DAC Reference Level) = 0xF
   * CPINH (Output Inhibit) = DISABLED (The comparator output will always
   *     reflect the input conditions.)
   * DACEN (DAC Enable) = ENABLED (Internal Reference DAC Enabled)
   */
  CMP1CN1 = CMP1CN1_DACEN__ENABLED | (0xF << CMP1CN1_DACLVL__SHIFT)
      | CMP1CN1_CPINH__DISABLED;

  // [CMP1CN1 - Comparator 1 Control 1]$

  // $[CMP1MD - Comparator 1 Mode]
  /*
   * CPINV (Invert Comparator output) = INVERT
   */
  CMP1MD = CMP1MD_CPINV__INVERT;
  // [CMP1MD - Comparator 1 Mode]$

  // $[CMP1CN0 - Comparator 1 Control 0]
  /*
   * CPEN (Comparator Enable) = ENABLED (Comparator enabled.)
   */
  CMP1CN0 |= CMP1CN0_CPEN__ENABLED;
  // [CMP1CN0 - Comparator 1 Control 0]$

}

//================================================================================
// TIMER16_2_enter_DefaultMode_from_RESET
//================================================================================
extern void TIMER16_2_enter_DefaultMode_from_RESET(void) {
  // $[Timer Initialization]
  // Save Timer Configuration
  uint8_t TMR2CN0_TR2_save;
  SFRPAGE = 0x00;
  TMR2CN0_TR2_save = TMR2CN0 & TMR2CN0_TR2__BMASK;
  // Stop Timer
  TMR2CN0 &= ~(TMR2CN0_TR2__BMASK);
  // [Timer Initialization]$

  // $[TMR2CN1 - Timer 2 Control 1]
  // [TMR2CN1 - Timer 2 Control 1]$

  // $[TMR2CN0 - Timer 2 Control]
  // [TMR2CN0 - Timer 2 Control]$

  // $[TMR2H - Timer 2 High Byte]
  // [TMR2H - Timer 2 High Byte]$

  // $[TMR2L - Timer 2 Low Byte]
  // [TMR2L - Timer 2 Low Byte]$

  // $[TMR2RLH - Timer 2 Reload High Byte]
  /*
   // TMR2RLH (Timer 2 Reload High Byte) = 0xCE
   */
  TMR2RLH = (0xCE << TMR2RLH_TMR2RLH__SHIFT);
  // [TMR2RLH - Timer 2 Reload High Byte]$

  // $[TMR2RLL - Timer 2 Reload Low Byte]
  /*
   // TMR2RLL (Timer 2 Reload Low Byte) = 0x27
   */
  TMR2RLL = (0x27 << TMR2RLL_TMR2RLL__SHIFT);
  // [TMR2RLL - Timer 2 Reload Low Byte]$

  // $[TMR2CN0]
  /*
   // TR2 (Timer 2 Run Control) = RUN (Start Timer 2 running.)
   */
  TMR2CN0 |= TMR2CN0_TR2__RUN;
  // [TMR2CN0]$

  // $[Timer Restoration]
  // Restore Timer Configuration
  TMR2CN0 |= TMR2CN0_TR2_save;
  // [Timer Restoration]$
}
