//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// -----------------------------------------------------------------------------
// Includes

#include <SI_EFM8UB3_Register_Enums.h>
#include "bsp.h"
#include "descriptor.h"

// -----------------------------------------------------------------------------
// Constants

// -------------------------------
// ADC Sampling Constants

#define SYSCLK                    48000000
#define ADC0_SAMPLING_FREQUENCY   4    // Frequency to sample ADC
#define T0_CLOCKS 120                  // Use 120 clocks per T0 Overflow

// SYSCLK cycles per interrupt
#define PCA_TIMEOUT ((SYSCLK/T0_CLOCKS)/ADC0_SAMPLING_FREQUENCY/4)

// -------------------------------
// Temperature Sensor Coefficients

#define SCALE       1000L   // Scale for temp calculations
#define SLOPE       2262    // Slope of the temp transfer function
#define OFFSET      265614L // Offset for the temp transfer function
#define OVER_ROUND  10      // Number of shifts (>>N) to reach the
                            // correct number of bits of precision

// -----------------------------------------------------------------------------
// Variables

uint16_t writeLen;

// -----------------------------------------------------------------------------
// Extern Variables

extern volatile uint8_t temperature;
extern bool btn0State;
extern bool btn1State;
extern volatile uint8_t joystick_val;
extern SI_SEGMENT_VARIABLE(inPacket[USB_PACKET_SIZE], uint8_t, SI_SEG_XDATA);

// -----------------------------------------------------------------------------
// Function Prototypes

// -----------------------------------------------------------------------------
// Functions

//-----------------------------------------------------------------------------
// ADC0EOC_ISR
//-----------------------------------------------------------------------------
//
// ADC0EOC ISR Content goes here. Remember to clear flag bits:
// ADC0CN0::ADINT (Conversion Complete Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(ADC0EOC_ISR, ADC0EOC_IRQn)
{
  // correct number of bits of precision
  int32_t temp_scaled;
  int16_t temp_frac;

  // Temperature Sensor reading
  temp_scaled = ADC0;
  temp_scaled *= SLOPE;

  // With a left-justified ADC, we have to shift the decimal place
  // of temp_scaled to the right so we can match the format of
  // OFFSET. Once the formats are matched, we can subtract OFFSET.
  temp_scaled = temp_scaled >> OVER_ROUND;
  temp_scaled -= OFFSET;

  // Calculate the temp's whole number portion by unscaling
  temperature = temp_scaled / SCALE;

  // Get the fractional part and round temperature as needed
  temp_frac = (int16_t)((temp_scaled - temperature * SCALE) / (SCALE / 10));

  if (temp_frac > 5)
  {
    temperature++;
  }
  else if (temp_frac < -5)
  {
    temperature--;
  }

  ADC0CN0_ADINT = 0;

  USBX_blockWrite(inPacket, USB_PACKET_SIZE, &writeLen);
  joystick_val++;
}

//-----------------------------------------------------------------------------
// INT0_ISR
//-----------------------------------------------------------------------------
//
// INT0 ISR Content goes here. Remember to clear flag bits:
// TCON::IE0 (External Interrupt 0)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(INT0_ISR, INT0_IRQn)
{
  // BTN0 is now low
  if ((IT01CF & IT01CF_IN0PL__BMASK) == IT01CF_IN0PL__ACTIVE_LOW)
  {
    IT01CF |= IT01CF_IN0PL__ACTIVE_HIGH;
  }
  // BTN0 is now high
  else
  {
    // At this point, BTN0 has been pressed and released.
    // Toggle btn0State
    btn0State = ~btn0State;
    IT01CF &= ~IT01CF_IN0PL__ACTIVE_HIGH;
  }
}

//-----------------------------------------------------------------------------
// INT1_ISR
//-----------------------------------------------------------------------------
//
// INT1 ISR Content goes here. Remember to clear flag bits:
// TCON::IE1 (External Interrupt 1)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(INT1_ISR, INT1_IRQn)
{
  // BTN1 is now low
  if ((IT01CF & IT01CF_IN1PL__BMASK) == IT01CF_IN1PL__ACTIVE_LOW)
  {
    IT01CF |= IT01CF_IN1PL__ACTIVE_HIGH;
  }
  // BTN1 is now high
  else
  {
    // At this point, BTN1 has been pressed and released.
    // Toggle btn1State
    btn1State = ~btn1State;
    IT01CF &= ~IT01CF_IN1PL__ACTIVE_HIGH;
  }
}
//-----------------------------------------------------------------------------
// PCA0_ISR
//-----------------------------------------------------------------------------
//
// PCA0 ISR Content goes here. Remember to clear flag bits:
// PCA0CN0::CCF0 (PCA Module 0 Capture/Compare Flag)
// PCA0CN0::CCF1 (PCA Module 1 Capture/Compare Flag)
// PCA0CN0::CCF2 (PCA Module 2 Capture/Compare Flag)
// PCA0CN0::CCF3 (PCA Module 3 Capture/Compare Flag)
// PCA0CN0::CCF4 (PCA Module 4 Capture/Compare Flag)
// PCA0CN0::CF (PCA Counter/Timer Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(PCA0_ISR, PCA0_IRQn)
{
  static uint16_t NEXT_COMPARE_VALUE;

  if (PCA0CN0_CCF0)                           // If Module 0 caused the interrupt
  {
     PCA0CN0_CCF0 = 0;                        // Clear module 0 interrupt flag.

     PCA0CPL0 = (NEXT_COMPARE_VALUE & 0x00FF);
     PCA0CPH0 = (NEXT_COMPARE_VALUE & 0xFF00)>>8;

     // Set up the variable for the following edge
     NEXT_COMPARE_VALUE = PCA0CP0 + PCA_TIMEOUT;

     // Trigger the next ADC measurement
     ADC0CN0_ADBUSY = 1;
  }
  else                                // Interrupt was caused by other bits.
  {
     PCA0CN0 &= ~0x86;                 // Clear other interrupt flags for PCA
  }
}
