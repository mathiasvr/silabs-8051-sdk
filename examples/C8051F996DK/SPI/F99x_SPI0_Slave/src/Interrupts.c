//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================


// USER INCLUDES
#include <SI_C8051F990_Register_Enums.h>

//-----------------------------------------------------------------------------
// Global Constants
//-----------------------------------------------------------------------------

#define MAX_BUFFER_SIZE    8           // Maximum buffer Master will send

// Instruction Set
#define  SLAVE_LED_ON      0x01        // Turn the Slave LED on
#define  SLAVE_LED_OFF     0x02        // Turn the Slave LED off
#define  SPI_WRITE         0x04        // Send a byte from the Master to the
                                       // Slave
#define  SPI_READ          0x08        // Send a byte from the Slave to the
                                       // Master
#define  SPI_WRITE_BUFFER  0x10        // Send a series of bytes from the
                                       // Master to the Slave
#define  SPI_READ_BUFFER   0x20        // Send a series of bytes from the Slave
                                       // to the Master
#define  ERROR_OCCURRED    0x40        // Indicator for the Slave to tell the
                                       // Master an error occurred

#define  LED_ON             0
#define  LED_OFF            1

SI_SBIT(LED, SFR_P1, 3);                 // LED==LED_ON means ON

//-----------------------------------------------------------------------------
// Global Variables
//-----------------------------------------------------------------------------

uint8_t SPI_Data = 0xA5;

uint8_t SPI_Data_Array[MAX_BUFFER_SIZE] = {0};

//-----------------------------------------------------------------------------
// SPI0_ISR
//-----------------------------------------------------------------------------
//
// SPI0 ISR Content goes here. Remember to clear flag bits:
// SPI0CN::MODF (Mode Fault Flag)
// SPI0CN::RXOVRN (Receive Overrun Flag)
// SPI0CN::SPIF (SPI# Interrupt Flag)
// SPI0CN::WCOL (Write Collision Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(SPI0_ISR, SPI0_IRQn)
{
	static uint8_t command;
	static uint8_t array_index = 0;
	static uint8_t state = 0;

	if (SPI0CN_WCOL == 1)
	{
	  // Write collision occurred

	  SPI0DAT = ERROR_OCCURRED;        // Indicate an error occurred
	  SPI0CN_WCOL = 0;                        // Clear the Write collision flag
	}
	else if (SPI0CN_RXOVRN == 1)
	{
	  // Receive overrun occurred

	  SPI0DAT = ERROR_OCCURRED;        // Indicate an error occurred
	  SPI0CN_RXOVRN = 0;                      // Clear the Receive Overrun flag
	}
	else
	{
	  // SPI0CN_SPIF caused the interrupt

	  // Some commands are single-byte commands (SLAVE_LED_ON/SLAVE_LED_OFF)
	  // For multiple-byte commands, use the state to determine action
	  // <state> == 0: new transfer; a command is being received
	  // <state> == 1: writing/reading data
	  if (state == 0)
	  {
		 command = SPI0DAT;            // Read the command

		 array_index = 0;              // Reset the array index

		 switch (command)
		 {
			case SPI_READ_BUFFER:
			   SPI0DAT = SPI_Data_Array[array_index]; // Immediately load
									   // SPI0DAT with the data requested by
									   // the Master, so the Master can receive
									   // it at the end of the second transfer.
									   // Because the slave sends the data
									   // immediately, the Master's SCK is
									   // limited to a clock slow enough that
									   // the Slave has time to respond to a
									   // read.

			   array_index++;

			   state = 1;              // Move to State 1 to continue to send
									   // data to the Master (multiple bytes).

			   break;
			case SLAVE_LED_ON:
			   LED = LED_ON;
			   state = 0;              // End of transfer (no bytes to send)

			   break;

			case SLAVE_LED_OFF:
			   LED = LED_OFF;
			   state = 0;              // End of transfer (no bytes to send)

			   break;

			case SPI_WRITE:
			   state = 1;              // Do nothing
									   // Move to State 1 to read data from
									   // Master

			   break;

			case SPI_READ:
			   SPI0DAT = SPI_Data;     // Immediately load SPI0DAT with the
									   // data requested by the Master, so the
									   // Master can receive it at the  end of
									   // the second transfer.
									   // Because the slave sends the data
									   // immediately, the Master's SCK is
									   // limited to a clock slow enough that
									   // the Slave has time to respond to a
									   // read.

			   state = 0;              // End of transfer (only one byte)

			   break;

			case SPI_WRITE_BUFFER:
			   state = 1;              // Do nothing
									   // Move to State 1 to read data from
									   // Master

			   break;

			default:
			   state = 0;
		 }

	  }
	  else if (state == 1)
	  {
		 SPI_Data = SPI0DAT;

		 switch (command)
		 {
			case SPI_WRITE:

			   state = 0;              // End of transfer (one byte received)

			   break;

			case SPI_WRITE_BUFFER:
			   SPI_Data_Array[array_index] = SPI_Data; // Receive the next byte

			   array_index++;

			   if (array_index == MAX_BUFFER_SIZE) // Check for last data
			   {
				  state = 0;           // Reset the state (end of transfer)
			   }
			   else
			   {
				  state = 1;           // Continue to read in data (more
									   // bytes to receive)
			   }

			   break;

			case SPI_READ_BUFFER:
			   SPI0DAT = SPI_Data_Array[array_index]; // Send the next byte

			   array_index++;

			   if (array_index == MAX_BUFFER_SIZE) // Check for last data
			   {
				  state = 0;           // Reset the state (end of transfer)
			   }
			   else
			   {
				  state = 1;           // Continue to send out data (more
									   // bytes to send)
			   }

			   break;

			default:
			   state = 0;
		 }
	  }

	  SPI0CN_SPIF = 0;                        // Clear the SPI0CN_SPIF flag
	}
}

