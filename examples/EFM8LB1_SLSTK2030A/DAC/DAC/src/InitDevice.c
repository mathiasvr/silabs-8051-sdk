//=========================================================
// src/InitDevice.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

// USER INCLUDES
#include <SI_EFM8LB1_Register_Enums.h>
#include "InitDevice.h"

// USER PROTOTYPES
// USER FUNCTIONS

// $[Library Includes]
// [Library Includes]$

//==============================================================================
// enter_DefaultMode_from_RESET
//==============================================================================
extern void enter_DefaultMode_from_RESET(void) {
	// $[Config Calls]
	// Save the SFRPAGE
	uint8_t SFRPAGE_save = SFRPAGE;
	WDT_0_enter_DefaultMode_from_RESET();
	PORTS_1_enter_DefaultMode_from_RESET();
	PORTS_3_enter_DefaultMode_from_RESET();
	PBCFG_0_enter_DefaultMode_from_RESET();
	DAC_0_enter_DefaultMode_from_RESET();
	DAC_1_enter_DefaultMode_from_RESET();
	DAC_2_enter_DefaultMode_from_RESET();
	DAC_3_enter_DefaultMode_from_RESET();
	DACGCF_0_enter_DefaultMode_from_RESET();
	VREF_0_enter_DefaultMode_from_RESET();
	CLOCK_0_enter_DefaultMode_from_RESET();
	// Restore the SFRPAGE
	SFRPAGE = SFRPAGE_save;
	// [Config Calls]$

}

//================================================================================
// WDT_0_enter_DefaultMode_from_RESET
//================================================================================
extern void WDT_0_enter_DefaultMode_from_RESET(void) {
	// $[Watchdog Timer Init Variable Declarations]
	// [Watchdog Timer Init Variable Declarations]$
	
	// $[WDTCN - Watchdog Timer Control]
	SFRPAGE = 0x00;
	//Disable Watchdog with key sequence
	WDTCN = 0xDE; //First key
	WDTCN = 0xAD; //Second key
	// [WDTCN - Watchdog Timer Control]$

}

//================================================================================
// PORTS_1_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTS_1_enter_DefaultMode_from_RESET(void) {
	// $[P1 - Port 1 Pin Latch]
	// [P1 - Port 1 Pin Latch]$

	// $[P1MDOUT - Port 1 Output Mode]
	/*
	 // B0 (Port 1 Bit 0 Output Mode) = OPEN_DRAIN (P1.0 output is open-
	 //     drain.)
	 // B1 (Port 1 Bit 1 Output Mode) = OPEN_DRAIN (P1.1 output is open-
	 //     drain.)
	 // B2 (Port 1 Bit 2 Output Mode) = OPEN_DRAIN (P1.2 output is open-
	 //     drain.)
	 // B3 (Port 1 Bit 3 Output Mode) = OPEN_DRAIN (P1.3 output is open-
	 //     drain.)
	 // B4 (Port 1 Bit 4 Output Mode) = PUSH_PULL (P1.4 output is push-pull.)
	 // B5 (Port 1 Bit 5 Output Mode) = OPEN_DRAIN (P1.5 output is open-
	 //     drain.)
	 // B6 (Port 1 Bit 6 Output Mode) = OPEN_DRAIN (P1.6 output is open-
	 //     drain.)
	 // B7 (Port 1 Bit 7 Output Mode) = OPEN_DRAIN (P1.7 output is open-
	 //     drain.)
	 */
	P1MDOUT = P1MDOUT_B0__OPEN_DRAIN | P1MDOUT_B1__OPEN_DRAIN
			| P1MDOUT_B2__OPEN_DRAIN | P1MDOUT_B3__OPEN_DRAIN
			| P1MDOUT_B4__PUSH_PULL | P1MDOUT_B5__OPEN_DRAIN
			| P1MDOUT_B6__OPEN_DRAIN | P1MDOUT_B7__OPEN_DRAIN;
	// [P1MDOUT - Port 1 Output Mode]$

	// $[P1MDIN - Port 1 Input Mode]
	// [P1MDIN - Port 1 Input Mode]$

	// $[P1SKIP - Port 1 Skip]
	// [P1SKIP - Port 1 Skip]$

	// $[P1MASK - Port 1 Mask]
	// [P1MASK - Port 1 Mask]$

	// $[P1MAT - Port 1 Match]
	// [P1MAT - Port 1 Match]$

}

//================================================================================
// PORTS_3_enter_DefaultMode_from_RESET
//================================================================================
extern void PORTS_3_enter_DefaultMode_from_RESET(void) {
	// $[P3 - Port 3 Pin Latch]
	// [P3 - Port 3 Pin Latch]$

	// $[P3MDOUT - Port 3 Output Mode]
	/*
	 // B0 (Port 3 Bit 0 Output Mode) = OPEN_DRAIN (P3.0 output is open-
	 //     drain.)
	 // B1 (Port 3 Bit 1 Output Mode) = OPEN_DRAIN (P3.1 output is open-
	 //     drain.)
	 // B2 (Port 3 Bit 2 Output Mode) = OPEN_DRAIN (P3.2 output is open-
	 //     drain.)
	 // B3 (Port 3 Bit 3 Output Mode) = OPEN_DRAIN (P3.3 output is open-
	 //     drain.)
	 // B4 (Port 3 Bit 4 Output Mode) = PUSH_PULL (P3.4 output is push-pull.)
	 // B7 (Port 3 Bit 7 Output Mode) = OPEN_DRAIN (P3.7 output is open-
	 //     drain.)
	 */
	SFRPAGE = 0x20;
	P3MDOUT = P3MDOUT_B0__OPEN_DRAIN | P3MDOUT_B1__OPEN_DRAIN
			| P3MDOUT_B2__OPEN_DRAIN | P3MDOUT_B3__OPEN_DRAIN
			| P3MDOUT_B4__PUSH_PULL | P3MDOUT_B7__OPEN_DRAIN;
	// [P3MDOUT - Port 3 Output Mode]$

	// $[P3MDIN - Port 3 Input Mode]
	// [P3MDIN - Port 3 Input Mode]$

}

//================================================================================
// PBCFG_0_enter_DefaultMode_from_RESET
//================================================================================
extern void PBCFG_0_enter_DefaultMode_from_RESET(void) {
	// $[XBR2 - Port I/O Crossbar 2]
	/*
	 // WEAKPUD (Port I/O Weak Pullup Disable) = PULL_UPS_ENABLED (Weak
	 //     Pullups enabled (except for Ports whose I/O are configured for analog
	 //     mode).)
	 // XBARE (Crossbar Enable) = ENABLED (Crossbar enabled.)
	 // URT1E (UART1 I/O Enable) = DISABLED (UART1 I/O unavailable at Port
	 //     pin.)
	 // URT1RTSE (UART1 RTS Output Enable) = DISABLED (UART1 RTS1 unavailable
	 //     at Port pin.)
	 // URT1CTSE (UART1 CTS Input Enable) = DISABLED (UART1 CTS1 unavailable
	 //     at Port pin.)
	 */
	SFRPAGE = 0x00;
	XBR2 = XBR2_WEAKPUD__PULL_UPS_ENABLED | XBR2_XBARE__ENABLED
			| XBR2_URT1E__DISABLED | XBR2_URT1RTSE__DISABLED
			| XBR2_URT1CTSE__DISABLED;
	// [XBR2 - Port I/O Crossbar 2]$

	// $[PRTDRV - Port Drive Strength]
	// [PRTDRV - Port Drive Strength]$

	// $[XBR0 - Port I/O Crossbar 0]
	// [XBR0 - Port I/O Crossbar 0]$

	// $[XBR1 - Port I/O Crossbar 1]
	// [XBR1 - Port I/O Crossbar 1]$

}

//================================================================================
// DAC_0_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC_0_enter_DefaultMode_from_RESET(void) {
	// $[DAC0CF0 - DAC0 Configuration 0]
	/*
	 // EN (DAC0 Enable) = ENABLE (DAC0 is enabled and will drive the output
	 //     pin.)
	 // UPDATE (DAC0 Update Trigger Source) = TIMER3 (DAC0 output updates
	 //     occur on Timer 3 high byte overflow.)
	 // LJST (DAC0 Left Justify Enable) = RIGHT_JUSTIFY (DAC0 input is treated
	 //     as right-justified.)
	 // RSTMD (DAC0 Reset Mode) = NORMAL (All resets will reset DAC0 and its
	 //     associated registers.)
	 */
	SFRPAGE = 0x30;
	DAC0CF0 = DAC0CF0_EN__ENABLE | DAC0CF0_UPDATE__TIMER3
			| DAC0CF0_LJST__RIGHT_JUSTIFY | DAC0CF0_RSTMD__NORMAL;
	// [DAC0CF0 - DAC0 Configuration 0]$

	// $[DAC0CF1 - DAC0 Configuration 1]
	// [DAC0CF1 - DAC0 Configuration 1]$

}

//================================================================================
// DAC_1_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC_1_enter_DefaultMode_from_RESET(void) {
	// $[DAC1CF0 - DAC1 Configuration 0]
	/*
	 // EN (DAC1 Enable) = ENABLE (DAC1 is enabled and will drive the output
	 //     pin.)
	 // UPDATE (DAC1 Update Trigger Source) = TIMER3 (DAC1 output updates
	 //     occur on Timer 3 high byte overflow.)
	 // LJST (DAC1 Left Justify Enable) = RIGHT_JUSTIFY (DAC1 input is treated
	 //     as right-justified.)
	 // RSTMD (DAC1 Reset Mode) = NORMAL (All resets will reset DAC1 and its
	 //     associated registers.)
	 */
	DAC1CF0 = DAC1CF0_EN__ENABLE | DAC1CF0_UPDATE__TIMER3
			| DAC1CF0_LJST__RIGHT_JUSTIFY | DAC1CF0_RSTMD__NORMAL;
	// [DAC1CF0 - DAC1 Configuration 0]$

	// $[DAC1CF1 - DAC1 Configuration 1]
	// [DAC1CF1 - DAC1 Configuration 1]$

}

//================================================================================
// DAC_2_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC_2_enter_DefaultMode_from_RESET(void) {
	// $[DAC2CF0 - DAC2 Configuration 0]
	/*
	 // EN (DAC2 Enable) = ENABLE (DAC2 is enabled and will drive the output
	 //     pin.)
	 // UPDATE (DAC2 Update Trigger Source) = TIMER3 (DAC2 output updates
	 //     occur on Timer 3 high byte overflow.)
	 // LJST (DAC2 Left Justify Enable) = RIGHT_JUSTIFY (DAC2 input is treated
	 //     as right-justified.)
	 // RSTMD (DAC2 Reset Mode) = NORMAL (All resets will reset DAC2 and its
	 //     associated registers.)
	 */
	DAC2CF0 = DAC2CF0_EN__ENABLE | DAC2CF0_UPDATE__TIMER3
			| DAC2CF0_LJST__RIGHT_JUSTIFY | DAC2CF0_RSTMD__NORMAL;
	// [DAC2CF0 - DAC2 Configuration 0]$

	// $[DAC2CF1 - DAC2 Configuration 1]
	// [DAC2CF1 - DAC2 Configuration 1]$

}

//================================================================================
// DAC_3_enter_DefaultMode_from_RESET
//================================================================================
extern void DAC_3_enter_DefaultMode_from_RESET(void) {
	// $[DAC3CF0 - DAC3 Configuration 0]
	/*
	 // EN (DAC3 Enable) = ENABLE (DAC3 is enabled and will drive the output
	 //     pin.)
	 // UPDATE (DAC3 Update Trigger Source) = TIMER3 (DAC3 output updates
	 //     occur on Timer 3 high byte overflow.)
	 // LJST (DAC3 Left Justify Enable) = RIGHT_JUSTIFY (DAC3 input is treated
	 //     as right-justified.)
	 // RSTMD (DAC3 Reset Mode) = NORMAL (All resets will reset DAC3 and its
	 //     associated registers.)
	 */
	DAC3CF0 = DAC3CF0_EN__ENABLE | DAC3CF0_UPDATE__TIMER3
			| DAC3CF0_LJST__RIGHT_JUSTIFY | DAC3CF0_RSTMD__NORMAL;
	// [DAC3CF0 - DAC3 Configuration 0]$

	// $[DAC3CF1 - DAC3 Configuration 1]
	// [DAC3CF1 - DAC3 Configuration 1]$

}

//================================================================================
// DACGCF_0_enter_DefaultMode_from_RESET
//================================================================================
extern void DACGCF_0_enter_DefaultMode_from_RESET(void) {
	// $[DACGCF0 - DAC Global Configuration 0]
	/*
	 // D01REFSL (DAC0 and DAC1 Reference Voltage Select) = VREF (Select the
	 //     VREF pin.)
	 // D23REFSL (DAC2 and DAC3 Reference Voltage Select) = VREF (Select the
	 //     VREF pin.)
	 // D1SRC (DAC1 Data Source) = DAC1 (Input = DAC1H:DAC1L.)
	 // D3SRC (DAC3 Data Source) = DAC3 (Input = DAC3H:DAC3L.)
	 // D1AMEN (DAC1 Alternating Mode Enable) = NORMAL (DAC1 always updates
	 //     from the data source selected in D1SRC. This mode may be used with any
	 //     trigger source.)
	 // D3AMEN (DAC3 Alternating Mode Enable) = NORMAL (DAC3 always updates
	 //     from the data source selected in D3SRC. This mode may be used with any
	 //     trigger source.)
	 */
	DACGCF0 = DACGCF0_D01REFSL__VREF | DACGCF0_D23REFSL__VREF
			| DACGCF0_D1SRC__DAC1 | DACGCF0_D3SRC__DAC3 | DACGCF0_D1AMEN__NORMAL
			| DACGCF0_D3AMEN__NORMAL;
	// [DACGCF0 - DAC Global Configuration 0]$

	// $[DACGCF2 - DAC Global Configuration 2]
	// [DACGCF2 - DAC Global Configuration 2]$

}

//================================================================================
// VREF_0_enter_DefaultMode_from_RESET
//================================================================================
extern void VREF_0_enter_DefaultMode_from_RESET(void) {
	// $[REF0CN - Voltage Reference Control]
	/*
	 // VREFSL (Voltage Reference Output Select) = VREF_2P4 (2.4 V reference
	 //     output to VREF pin.)
	 */
	SFRPAGE = 0x00;
	REF0CN = REF0CN_VREFSL__VREF_2P4;
	// [REF0CN - Voltage Reference Control]$

}

//================================================================================
// CLOCK_0_enter_DefaultMode_from_RESET
//================================================================================
extern void CLOCK_0_enter_DefaultMode_from_RESET(void) {
	// $[HFOSC1 Setup]
	// [HFOSC1 Setup]$

	// $[CLKSEL - Clock Select]
	/*
	 // CLKSL (Clock Source Select) = HFOSC0 (Clock derived from the Internal
	 //     High Frequency Oscillator 0.)
	 // CLKDIV (Clock Source Divider) = SYSCLK_DIV_1 (SYSCLK is equal to
	 //     selected clock source divided by 1.)
	 // CLKSL (Clock Source Select) = HFOSC0 (Clock derived from the Internal
	 //     High Frequency Oscillator 0.)
	 // CLKDIV (Clock Source Divider) = SYSCLK_DIV_1 (SYSCLK is equal to
	 //     selected clock source divided by 1.)
	 */
	CLKSEL = CLKSEL_CLKSL__HFOSC0 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
	CLKSEL = CLKSEL_CLKSL__HFOSC0 | CLKSEL_CLKDIV__SYSCLK_DIV_1;
	while (CLKSEL & CLKSEL_DIVRDY__BMASK == CLKSEL_DIVRDY__NOT_READY)
		;
	// [CLKSEL - Clock Select]$

}

