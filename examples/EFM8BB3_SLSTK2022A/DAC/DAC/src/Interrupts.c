//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================

         
// USER INCLUDES			
#include <SI_EFM8BB3_Register_Enums.h>

//-----------------------------------------------------------------------------
// Global Constants
//-----------------------------------------------------------------------------
SI_SBIT(LED0, SFR_P1, 4);                  // P1.4 LED0
SI_SBIT(LED1, SFR_P1, 5);                  // P1.5 LED1
SI_SBIT(LED2, SFR_P1, 6);                  // P1.6 LED2

#define SYSCLK          24500000       // SYSCLK frequency in Hz

#define SAMPLE_RATE_DAC 200000L        // DAC sampling rate in Hz

#define PHASE_PRECISION 65536          // Range of phase accumulator

#define FREQUENCY       1000L          // Frequency of output in Hz

#define PHASE_ADD       (FREQUENCY * PHASE_PRECISION / SAMPLE_RATE_DAC)

// A full cycle, 12-bit, unsigned sine wave lookup table
SI_SEGMENT_VARIABLE(SINE_TABLE[256], uint16_t, const SI_SEG_CODE) = 
{
   0x7FF, 0x831, 0x863, 0x895, 0x8C7, 0x8F9, 0x92B, 0x95C,
   0x98E, 0x9BF, 0x9F0, 0xA20, 0xA51, 0xA81, 0xAB0, 0xADF,
   0xB0E, 0xB3C, 0xB6A, 0xB97, 0xBC3, 0xBEF, 0xC1B, 0xC46,
   0xC70, 0xC99, 0xCC2, 0xCEA, 0xD11, 0xD38, 0xD5D, 0xD82,
   0xDA6, 0xDC9, 0xDEB, 0xE0D, 0xE2D, 0xE4C, 0xE6B, 0xE88,
   0xEA5, 0xEC0, 0xEDA, 0xEF4, 0xF0C, 0xF23, 0xF39, 0xF4E,
   0xF62, 0xF74, 0xF86, 0xF96, 0xFA5, 0xFB3, 0xFC0, 0xFCC,
   0xFD6, 0xFDF, 0xFE7, 0xFEE, 0xFF4, 0xFF8, 0xFFB, 0xFFD,
   0xFFE, 0xFFD, 0xFFB, 0xFF8, 0xFF4, 0xFEE, 0xFE7, 0xFDF,
   0xFD6, 0xFCC, 0xFC0, 0xFB3, 0xFA5, 0xF96, 0xF86, 0xF74,
   0xF62, 0xF4E, 0xF39, 0xF23, 0xF0C, 0xEF4, 0xEDA, 0xEC0,
   0xEA5, 0xE88, 0xE6B, 0xE4C, 0xE2D, 0xE0D, 0xDEB, 0xDC9,
   0xDA6, 0xD82, 0xD5D, 0xD38, 0xD11, 0xCEA, 0xCC2, 0xC99,
   0xC70, 0xC46, 0xC1B, 0xBEF, 0xBC3, 0xB97, 0xB6A, 0xB3C,
   0xB0E, 0xADF, 0xAB0, 0xA81, 0xA51, 0xA20, 0x9F0, 0x9BF,
   0x98E, 0x95C, 0x92B, 0x8F9, 0x8C7, 0x895, 0x863, 0x831,
   0x7FF, 0x7CC, 0x79A, 0x768, 0x736, 0x704, 0x6D2, 0x6A1,
   0x66F, 0x63E, 0x60D, 0x5DD, 0x5AC, 0x57C, 0x54D, 0x51E,
   0x4EF, 0x4C1, 0x493, 0x466, 0x43A, 0x40E, 0x3E2, 0x3B7,
   0x38D, 0x364, 0x33B, 0x313, 0x2EC, 0x2C5, 0x2A0, 0x27B,
   0x257, 0x234, 0x212, 0x1F0, 0x1D0, 0x1B1, 0x192, 0x175,
   0x158, 0x13D, 0x123, 0x109, 0x0F1, 0x0DA, 0x0C4, 0x0AF,
   0x09B, 0x089, 0x077, 0x067, 0x058, 0x04A, 0x03D, 0x031,
   0x027, 0x01E, 0x016, 0x00F, 0x009, 0x005, 0x002, 0x001,
   0x000, 0x001, 0x002, 0x005, 0x009, 0x00F, 0x016, 0x01E,
   0x027, 0x031, 0x03D, 0x04A, 0x058, 0x067, 0x077, 0x089,
   0x09B, 0x0AF, 0x0C4, 0x0DA, 0x0F1, 0x109, 0x123, 0x13D,
   0x158, 0x175, 0x192, 0x1B1, 0x1D0, 0x1F0, 0x212, 0x234,
   0x257, 0x27B, 0x2A0, 0x2C5, 0x2EC, 0x313, 0x33B, 0x364,
   0x38D, 0x3B7, 0x3E2, 0x40E, 0x43A, 0x466, 0x493, 0x4C1,
   0x4EF, 0x51E, 0x54D, 0x57C, 0x5AC, 0x5DD, 0x60D, 0x63E,
   0x66F, 0x6A1, 0x6D2, 0x704, 0x736, 0x768, 0x79A, 0x7CC,
};

//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN::TF2H (Timer # High Byte Overflow Flag)
// TMR3CN::TF2L (Timer # Low Byte Overflow Flag)
//
// This routine changes the state of the LED whenever Timer3 overflows.
//
//-----------------------------------------------------------------------------

SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
{
   uint8_t SFRPAGE_save = SFRPAGE;

   static uint16_t phase_acc = 0;      // Holds phase accumulator

   SI_UU16_t temp;                     // The temporary value that holds
									   // value before being written
									   // to the IDAC

   SI_VARIABLE_SEGMENT_POINTER(table_ptr, uint16_t, const SI_SEG_CODE);  // Pointer to the lookup table


   TMR3CN0 &= ~0x80;                   // Clear Timer3 overflow flag

   table_ptr = SINE_TABLE;

   phase_acc += PHASE_ADD;             // Increment phase accumulator


   // Read the table value
   temp.u16 = *(table_ptr + (phase_acc >> 8));

   // Set the value of <temp> to the next output of DAC at full-scale
   // amplitude. The rails are 0x000 and 0xFFF. DAC low byte must be
   // written first.

   SFRPAGE = PG4_PAGE;

   DAC0L = temp.u8[LSB];
   DAC0H = temp.u8[MSB];

   DAC1L = temp.u8[LSB];
   DAC1H = temp.u8[MSB];

   SFRPAGE = SFRPAGE_save;

}

