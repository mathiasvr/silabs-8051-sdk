//=========================================================
// src/Interrupts.c: generated by Hardware Configurator
//
// This file will be regenerated when saving a document.
// leave the sections inside the "$[...]" comment tags alone
// or they will be overwritten!
//=========================================================


// USER INCLUDES
#include "main.h"
#include "smbus.h"

//-----------------------------------------------------------------------------
// SMBUS0_ISR
//-----------------------------------------------------------------------------
//
// SMBUS0 ISR Content goes here. Remember to clear flag bits:
// SMB0CN::SI (SMBus Interrupt Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(SMBUS0_ISR, SMBUS0_IRQn)
{
    bool FAIL = 0;                       // Used by the ISR to flag failed
                                        // transfers
    static bool ADDR_SEND = 0;           // Used by the ISR to flag byte
                                        // transmissions as slave addresses

    if (SMB0CN0_ARBLOST == 0)            // Check for errors
    {
      // Normal operation
      switch (SMB0CN0 & 0xF0)            // Status vector
      {
             // Master Transmitter/Receiver: START condition transmitted.
             case SMB_MTSTA:
                    SMB0DAT = TARGET;   // Load address of the target slave
                    SMB0DAT &= 0xFE;    // Clear the LSB of the address for the
                                        // R/W bit
                    SMB0DAT |= SMB_RW;  // Load R/W bit
                    SMB0CN0_STA = 0;     // Manually clear START bit
                    ADDR_SEND = 1;
                    break;

             // Master Transmitter: Data byte transmitted
             case SMB_MTDB:
                    if (SMB0CN0_ACK)            // Slave SMB0CN_ACK?
                    {
                       if (ADDR_SEND)          // If the previous byte was a slave
                       {                       // address,
                              ADDR_SEND = 0;   // Next byte is not a slave address
                              if (SMB_RW == WRITE) // If this transfer is a WRITE,
                              {
                                     // send data byte
                                     SMB0DAT = SMB_DATA_OUT;
                              }
                              else {}          // If this transfer is a READ,
                                               // proceed with transfer without
                                               // writing to SMB0DAT (switch
                                               // to receive mode)
                       }
                       else                    // If previous byte was not a slave
                       {                       // address,
                              SMB0CN0_STO = 1;  // Set SMB0CN_STO to terminate transfer
                              SMB_BUSY = 0;    // And free SMBus interface
                       }
                    }
                    else                       // If slave NACK,
                    {
                       SMB0CN0_STO = 1;         // Send STOP condition, followed
                       SMB0CN0_STA = 1;         // By a START
                       NUM_ERRORS++;           // Indicate error
                    }
                    break;

             // Master Receiver: byte received
             case SMB_MRDB:
                    SMB_DATA_IN = SMB0DAT;     // Store received byte
                    SMB_BUSY = 0;              // Free SMBus interface
                    SMB0CN0_ACK = 0;            // Send NACK to indicate last byte
                                               // of this transfer

                    SMB0CN0_STO = 1;            // Send STOP to terminate transfer
                    break;

             default:
                    FAIL = 1;                  // Indicate failed transfer
                                               // and handle at end of ISR
                    break;

      } // end switch
    }
    else
    {
      // SMB0CN_ARBLOST = 1, error occurred... abort transmission
      FAIL = 1;
    } // end SMB0CN_ARBLOST if

    if (FAIL)                                  // If the transfer failed,
    {
      SMB0CF &= ~0x80;                         // Reset communication
      SMB0CF |= 0x80;
      SMB0CN0_STA = 0;
      SMB0CN0_STO = 0;
      SMB0CN0_ACK = 0;

      SMB_BUSY = 0;                            // Free SMBus

      FAIL = 0;

      NUM_ERRORS++;                            // Indicate an error occurred
    }

    SMB0CN0_SI = 0;                             // Clear interrupt flag
}

#if 0
//-----------------------------------------------------------------------------
// TIMER3_ISR
//-----------------------------------------------------------------------------
//
// TIMER3 ISR Content goes here. Remember to clear flag bits:
// TMR3CN::TF3H (Timer # High Byte Overflow Flag)
// TMR3CN::TF3L (Timer # Low Byte Overflow Flag)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(TIMER3_ISR, TIMER3_IRQn)
{
    SMB0CF &= ~0x80;                    // Disable SMBus
    SMB0CF |= 0x80;                     // Re-enable SMBus
    TMR3CN0 &= ~0x80;                    // Clear Timer3 interrupt-pending flag
    SMB0CN0_STA = 0;
    SMB_BUSY = 0;                       // Free SMBus
}
#endif

//-----------------------------------------------------------------------------
// VDDMON_ISR
//-----------------------------------------------------------------------------
//
// VDDMON ISR Content goes here. Remember to clear flag bits:
// VDM0CN::VDDOK (V<subscript>DD</subscript> Supply Status (Early Warning))
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(VDDMON_ISR, VDDMON_IRQn)
{

}

//-----------------------------------------------------------------------------
// RTC0ALARM_ISR
//-----------------------------------------------------------------------------
//
// RTC0ALARM ISR Content goes here. Remember to clear flag bits:
// RTC0CN::ALRM (RTC Alarm Event Flag and Auto Reset Enable)
//
//-----------------------------------------------------------------------------
SI_INTERRUPT(RTC0ALARM_ISR, RTC0ALARM_IRQn)
{
    uint8_t RTC0CN_save;
    
    RTC0ADR = RTC0ADR_ADDR__RTC0CN0 | RTC0ADR_SHORT__ENABLED | RTC0ADR_BUSY__SET;
    NOP(); NOP(); NOP();
    NOP(); NOP(); NOP();
    RTC0CN_save = RTC0DAT;
    RTC0DAT = RTC0CN_save & RTC0CN0_RTC0AEN__DISABLED;
    NOP();
    NOP();
    RTC0DAT = RTC0CN_save | RTC0CN0_RTC0AEN__ENABLED;
    NOP();
    NOP();

#if (MEASUREMENT_INTERVAL == SECONDS) || (MEASUREMENT_INTERVAL == TWO_SECONDS)
    if(seconds == 59)
    {
        seconds = 0;
        if(minutes == 59)
        {
            minutes = 0;
            if(hours == 255)
            {
                hours = 0;
            }
            else
            {
                hours++;
            }
        }
        else
        {
            minutes++;
        }
    }
    else
    {
        seconds++;
    }

#if (MEASUREMENT_INTERVAL == SECONDS)
    alarmWakeUp = 1;
#else
    if ((seconds % 2) == 0)
    {
        alarmWakeUp = 1;
    }
#endif

#elif MEASUREMENT_INTERVAL == MINUTES
    if(minutes == 59)
    {
        minutes = 0;
        if(hours == 255)
        {
            hours = 0;
        }
        else
        {
            hours++;
        }
    }
    else
    {
        minutes++;
    }

    alarmWakeUp = 1;

#else
    if(hours == 255)
    {
        hours = 0;
    }
    else
    {
        hours++;
    }
    alarmWakeUp = 1;
#endif
}
